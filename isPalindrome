public boolean isPalindrome() {
    if (first == null || first.next == null) {
        return true; // Empty or single-element list is palindrome
    }

    // Step 1: Find the middle using slow and fast pointers
    Node slow = first;
    Node fast = first;
    while (fast != null && fast.next != null) {
        slow = slow.next;
        fast = fast.next.next;
    }

    // Step 2: Reverse the second half
    Node prev = null;
    Node current = slow;
    while (current != null) {
        Node nextNode = current.next;
        current.next = prev;
        prev = current;
        current = nextNode;
    }

    // Step 3: Compare both halves
    Node left = first;
    Node right = prev; // head of reversed second half
    boolean palindrome = true;

    while (right != null) {
        if (left.data != right.data) {
            palindrome = false;
            break;
        }
        left = left.next;
        right = right.next;
    }

    // Step 4: (Optional) Reverse the second half back to restore list
    current = prev;
    prev = null;
    while (current != null) {
        Node nextNode = current.next;
        current.next = prev;
        prev = current;
        current = nextNode;
    }

    return palindrome;
}
